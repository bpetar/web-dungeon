<!DOCTYPE html>
<html lang="en">
	<head>
		<title>cuber</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #eee;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container" style="position:absolute;">
		</div>
		
		<div id="gui" style="position:absolute; left:70px; top:70px;">
			<div id="player1" style="border:2px solid;">
				<div id="player1top" style="border:1px solid red; float: left;">
					<div id="player1topimg" style="float: left;">
					<img src="media/profile1.jpg" onClick='inventory_show("Inventory will popup here!")'> 
					</div>
					<div id="player1tophand" style="margin-left: 110px;">
					<img src="media/health.png"> 
					<br>
					<img src="media/mace.png" onClick='alert("Smash!")'> 
					</div>
				</div>
				<br>
				Drn Inatdzija
			</div>
			<br>
			<br>
			<div id="player2" style="border:2px solid;">
				<div id="player1top" style="border:1px solid red; float: left;">
					<div id="player1topimg" style="float: left;">
					<img src="media/profile2.jpg" onClick='inventory_show("Inventory will popup here!")'> 
					</div>
					<div id="player1tophand" style="margin-left: 110px;">
					<img src="media/health.png"> 
					<br>
					<img src="media/staff.png" onClick='alert("Swing!")'> 
					</div>
				</div>
				<br>
				Mech Cloaker
			</div>
		</div>
		<div id="inventory" style="display:none; position:absolute; left:310px; top:70px;">
			<img src="media/inventory.png" onClick='hide("Inventory not yet implemented!")'> 
		</div>

		<div id="gui_bar" style="position:absolute; background: url(media/bar.png) repeat-x; height:50px; width:100%; bottom:-37px;">
		&nbsp;
		</div>
		<div id="gui_left" style="position:absolute; left:-36px; bottom:-40px;">
			<img src="media/left.png" > 
		</div>
		<div id="gui_right" style="position:absolute; right:-36px; bottom:-40px;">
			<img src="media/right.png" > 
		</div>

		<div id="gui_slots" style="position:absolute; left:256px; bottom:-170px;">
			<div id="gui_slot1" style="float:left;">
				<div id="gui_slot1_item" style="float:left;">
					<img id="gui_slot1_item_icon" src="media/none.png"> 
				</div>
				<div id="gui_slot1_border" style="position:absolute;">
					<img src="media/slot.png"> 
				</div>
			</div>
			<div id="gui_slot2" style="float:left;">
				<div id="gui_slot2_item" style="float:left;">
					<img id="gui_slot2_item_icon" src="media/none.png"> 
				</div>
				<div id="gui_slot2_border" style="position:absolute;">
					<img src="media/slot.png"> 
				</div> 
			</div>
			<div id="gui_slot3" style="float:left;">
				<div id="gui_slot3_item" style="float:left;">
					<img id="gui_slot3_item_icon" src="media/none.png"> 
				</div>
				<div id="gui_slot3_border" style="position:absolute;">
					<img src="media/slot.png"> 
				</div> 
			</div>
			<div id="gui_slot41" style="float:left;">
				<div id="gui_slot4_item" style="float:left;">
					<img id="gui_slot4_item_icon" src="media/none.png"> 
				</div>
				<div id="gui_slot4_border" style="position:absolute;">
					<img src="media/slot.png"> 
				</div> 
			</div>
		</div>
		
		<script src="./source/pickables.js"></script>
		<script src="./source/containers.js"></script>
		<script src="./source/game_object.js"></script>
		<script src="./source/inventory.js"></script>
		<script src="./source/three.min.js"></script>
		<script src="./source/niche.js"></script>

		<script>
		
			clickConsumed = false;

			function inventory_show(param) {
				//show inventory if hidden, hide elsewhere
				if(inventory_div_vertical_pos == INVENTORY_POS_HIDDEN)
				{
					inventorySlide = 1;
				}
				else
				{
					inventorySlide = -1;
				}
			}
			
			function hide(param) {
				alert(param);
				//clickConsumed = true;
				//var ele = document.getElementById("inventory");
				//ele.style.display = "none";
			}

			var SQUARE_SIZE = 10;

			var floorsArr2D = [[4,0], [4,1], [4,2], [4,3], [4,4], [4,5], [5,2], [6,2], [6,3], [6,4], [3,2], [2,2], [2,3], [2,4], [2,5]];
			//var wallsArr2D = [];
			var doorsArr3D = [[4,3,0,0,0], [2,3,0,0,0], [6,3,0,0,0]]; //x,z,rot,open,mesh, 
			var holesArr = [[2,4], [4,4]];
			var holeFallen = false;
			
			var alerted = false;
			
			var container;
			
			var pickable_at_hand;
			var pickable_at_hand_icon;
			
						var projector, mouse = { x: 0, y: 0 }, INTERSECTED;


			var camera, scene, renderer;

			var mesh, mesh2, mesh3, light;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var current_position;
			var NUM_SLOTS_INVENTORY_ROW = 4;
			var SLOT_WIDTH = 128;
			var inventorySlide = 0;
			var inventory_div;
			var INVENTORY_POS_HIDDEN = -170;
			var INVENTORY_POS_SHOWN = 8;
			var inventory_div_vertical_pos = INVENTORY_POS_HIDDEN;
			
			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );
				
				//createWallsFromFloors();
				
				document.onkeydown = handleKeyDown;

				camera = new THREE.PerspectiveCamera( 47, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.x = 40;
				camera.position.y = 4;
				camera.position.z = -5;
				camera.look = new THREE.Vector3(40,4,5);
				camera.lookAt(camera.look);
				
				current_position = new THREE.Vector3(4,0,0);

				scene = new THREE.Scene();
				
				inventory_div = document.getElementById('gui_slots');
				inventory_div.style.left = (windowHalfX - (NUM_SLOTS_INVENTORY_ROW/2*SLOT_WIDTH)) +'px';

				light = new THREE.SpotLight();
				light.position.set( -40, 60, 40 );
				light.castShadow = true;
				scene.add( light );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( 50, 50, 50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( -50, -50, -50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );

				//load pickables
				load_pickables();
				
				//load niches
				loadNiches();
				
				//load chests
				load_containers();
				
				var loader = new THREE.JSONLoader();

				//loader.load( "models/tost.js", createScene1 );
				loader.load( "models/doorway.js", createScene1 );
				loader.load( "models/door.js", createScene2 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMapWidth = 128;;
				renderer.shadowMapHeight = 128;
				renderer.shadowCameraFov = 50;

				container.appendChild( renderer.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onMouseClick, false );

				//
				/////// draw text on canvas /////////

				// create a canvas element
				var canvas1 = document.createElement('canvas');
				var context1 = canvas1.getContext('2d');
				context1.font = "Bold 20px Arial";
				//context1.fillStyle = "rgba(1,1,0,0.95)";
				//context1.fillText('Hello, world!', 10, 20);
				
				context1.clearRect(0,0,640,480);
				var message = "Pera";
				var metrics = context1.measureText(message);
				var width = metrics.width;
				context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
				context1.fillRect( 0,0, width+8,20+8);
				context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
				context1.fillRect( 2,2, width+4,20+4 );
				context1.fillStyle = "rgba(0,0,0,1)"; // text color
				context1.fillText( message, 4,20 );
				
				// canvas contents will be used for a texture
				var texture1 = new THREE.Texture(canvas1) 
				texture1.needsUpdate = true;
				
				////////////////////////////////////////
				
				var spriteMaterial = new THREE.SpriteMaterial( { map: texture1, useScreenCoordinates: true, alignment: THREE.SpriteAlignment.topLeft } );
				
				var sprite1 = new THREE.Sprite( spriteMaterial );
				sprite1.scale.set(200,200,1.0);
				sprite1.position.set( 50, 15, 0 );
				scene.add( sprite1 );	
				
				/////// draw text on canvas /////////
				
				// initialize object to perform world/screen calculations
				projector = new THREE.Projector();


				window.addEventListener( 'resize', onWindowResize, false );

				var map = THREE.ImageUtils.loadTexture( 'media/floor.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

				var material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );

				//floors
				for(var i=0; i < floorsArr2D.length; i++)
				{
					holeSpot = false;
					for (var h=0; h<holesArr.length; h++)
					{
						if((holesArr[h][0] == floorsArr2D[i][0]) && (holesArr[h][1] == floorsArr2D[i][1]))
						holeSpot = true;
					}
					//if this floor tile is hole, make a hole, else make floor
					
					if(holeSpot)
					{
						var pos = new THREE.Vector3(0, 0, 0);
						var rot = new THREE.Vector3(0, 0, 0);
						pos.x = floorsArr2D[i][0]*SQUARE_SIZE;
						pos.z = floorsArr2D[i][1]*SQUARE_SIZE;
						loader.load( "models/hole.js", loadModel(pos,rot) );
					}
					else
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(-Math.PI/2, 0, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0; //y
						object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
				}
				
				//ceiling
				
				map = THREE.ImageUtils.loadTexture( 'media/ceiling.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0.8*SQUARE_SIZE; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//walls
				
				map = THREE.ImageUtils.loadTexture( 'media/wall.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					var leftWall = true;
					var rightWall = true;
					var frontWall = true;
					var backWall = true;
					var xTile = floorsArr2D[i][0];
					var yTile = floorsArr2D[i][1];
					//make walls around floor tile, but check if it has neighboring tile..
					for(j=0; j < floorsArr2D.length; j++)
					{
						if(i!=j)
						{
							if((floorsArr2D[j][0] == xTile+1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the left - no LeftWall.
								leftWall = false;
							}
							if((floorsArr2D[j][0] == xTile-1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the right - no RightWall.
								rightWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile+1))
							{
								//there is floor tile to the front - no FrontWall.
								frontWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile-1))
							{
								//there is floor tile to the back - no BackWall.
								backWall = false;
							}
						}
					}
					
					if(leftWall)
					{
						var nicheIsOnTheWall = false;
						//loop nicheArr
						for (var n=0; n<nicheArr.length; n++)
						{
							if((nicheArr[n][0] == floorsArr2D[i][0])&&(nicheArr[n][1] == floorsArr2D[i][1])&&(nicheArr[n][2] == 3))
							{
								nicheIsOnTheWall = true;
							}
						}
						
						if(nicheIsOnTheWall)
						{
							//load niche model instead of regular wall
							var pos = new THREE.Vector3(0, 0, 0);
							var rot = new THREE.Vector3(0, 0, 0);
							pos.set((floorsArr2D[i][0]+0.5)*SQUARE_SIZE,0.4*SQUARE_SIZE,(floorsArr2D[i][1])*SQUARE_SIZE);
							rot.set(0, -Math.PI/2, 0);
							loader.load( "models/niche.js", loadModel(pos, rot) );
						}
						else
						{
							//load regular wall
							object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
							//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
							object.rotation.set(0, Math.PI/2, 0);
							object.receiveShadow = true;
							
						
							object.position.x = (floorsArr2D[i][0]+0.5)*SQUARE_SIZE; //x
							object.position.y = 0.4*SQUARE_SIZE; //y
							object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
					
							//alert(object.position.x);
							scene.add( object );
						}
					}
					if(rightWall)
					{
						var nicheIsOnTheWall = false;
						//loop nicheArr
						//alert("right wall");
						for (var n=0; n<nicheArr.length; n++)
						{
							//alert("right wall for " + nicheArr[n][0] + "," + nicheArr[n][1] + " = " + floorsArr2D[i][0] + "," + floorsArr2D[i][1]);
							if((nicheArr[n][0] == floorsArr2D[i][0])&&(nicheArr[n][1] == floorsArr2D[i][1])&&(nicheArr[n][2] == 1))
							{
								nicheIsOnTheWall = true;
							}
						}
						
						if(nicheIsOnTheWall)
						{
							//load niche model instead of regular wall
							var pos = new THREE.Vector3(0, 0, 0);
							var rot = new THREE.Vector3(0, 0, 0);
							pos.set((floorsArr2D[i][0]-0.5)*SQUARE_SIZE,0.4*SQUARE_SIZE,(floorsArr2D[i][1])*SQUARE_SIZE);
							rot.set(0, Math.PI/2, 0);
							loader.load( "models/niche.js", loadModel(pos, rot) );
						}
						else
						{
							//load regular wall
							object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
							//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
							object.rotation.set(0, Math.PI/2, 0);
							object.receiveShadow = true;
							
						
							object.position.x = (floorsArr2D[i][0]-0.5)*SQUARE_SIZE; //x
							object.position.y = 0.4*SQUARE_SIZE; //y
							object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
					
							//alert(object.position.x);
							scene.add( object );
						}
					}
					if(frontWall)
					{
						var nicheIsOnTheWall = false;
						//loop nicheArr
						for (var n=0; n<nicheArr.length; n++)
						{
							if((nicheArr[n][0] == floorsArr2D[i][0])&&(nicheArr[n][1] == floorsArr2D[i][1])&&(nicheArr[n][2] == 0))
							{
								nicheIsOnTheWall = true;
							}
						}
						
						if(nicheIsOnTheWall)
						{
							//load niche model instead of regular wall
							var pos = new THREE.Vector3(0, 0, 0);
							var rot = new THREE.Vector3(0, 0, 0);
							pos.set((floorsArr2D[i][0])*SQUARE_SIZE,0.4*SQUARE_SIZE,(floorsArr2D[i][1]+0.5)*SQUARE_SIZE);
							rot.set(0, Math.PI, 0);
							loader.load( "models/niche.js", loadModel(pos, rot) );
						}
						else
						{
							//load regular wall
							object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
							//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
							object.rotation.set(0, Math.PI, 0);
							object.receiveShadow = true;
							
						
							object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
							object.position.y = 0.4*SQUARE_SIZE; //y
							object.position.z = (floorsArr2D[i][1]+0.5)*SQUARE_SIZE; //z
					
							//alert(object.position.x);
							scene.add( object );
						}
					}
					if(backWall)
					{
						var nicheIsOnTheWall = false;
						//loop nicheArr
						for (var n=0; n<nicheArr.length; n++)
						{
							if((nicheArr[n][0] == floorsArr2D[i][0])&&(nicheArr[n][1] == floorsArr2D[i][1])&&(nicheArr[n][2] == 2))
							{
								alert(" niche");
								nicheIsOnTheWall = true;
							}
						}
						
						if(nicheIsOnTheWall)
						{
							//load niche model instead of regular wall
							var pos = new THREE.Vector3(0, 0, 0);
							var rot = new THREE.Vector3(0, 0, 0);
							pos.set((floorsArr2D[i][0])*SQUARE_SIZE,0.4*SQUARE_SIZE,(floorsArr2D[i][1]-0.5)*SQUARE_SIZE);
							rot.set(0, 0, 0);
							loader.load( "models/niche.js", loadModel(pos, rot) );
						}
						else
						{
							//load regular wall
							object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
							//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
							object.rotation.set(0, Math.PI, 0);
							object.receiveShadow = true;
							
						
							object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
							object.position.y = 0.4*SQUARE_SIZE; //y
							object.position.z = (floorsArr2D[i][1]-0.5)*SQUARE_SIZE; //z
					
							//alert(object.position.x);
							scene.add( object );
						}
					}
					
					
				}
  
				renderer.shadowMapEnabled = true;

			}

			//decide weather step is possible (hitting walls)
			function canMoveTo(x, z)
			{
				var i = 0;
				var j = 0;
				
				//if player fell in hole, make sure he cant move around :)
				if(holeFallen)
					return false;
					
				//alert("pera " + x + " " + z);
				for(i=0; i < floorsArr2D.length; i++)
				{
					if((floorsArr2D[i][0] == x) && (floorsArr2D[i][1] == z))
					{
						for(j=0; j < doorsArr3D.length; j++)
						{
							//if there are closed doors in that position..
							if((doorsArr3D[j][0] == x) && (doorsArr3D[j][1] == z)) 
							{
								if(doorsArr3D[j][3] == 0) return false;
							}
						}
						return true;
					}
				}
				return false;
			}
			
			//check if that position is hole in the floor
			function positionIsHole(x,z) {
				
				//loop through holes array
				for(i=0;i<holesArr.length;i++)
				{
					if((holesArr[i][0] == x)&&(holesArr[i][1] == z))
					{
						return true;
					}
				}
				return false;
			}
			
			function fallInHole()
			{
				holeFallen = true;
			}
			

			//
			function handleKeyDown(event) {
				//alert(event.keyCode);
				//if (event.keyCode == 88) {animateDoor = true;}
				
				//Movement:
				var looker = new THREE.Vector3(0, 0, 0);
				looker.x = camera.look.x;
				looker.y = camera.look.y;
				looker.z = camera.look.z;
					
				looker.sub(camera.position);
				
				//Key I = Inventory
				//alert(event.keyCode);
				if (event.keyCode == 73) {
					//show inventory if hidden, hide elsewhere
					if(inventory_div_vertical_pos == INVENTORY_POS_HIDDEN)
					{
						inventorySlide = 1;
					}
					else
					{
						inventorySlide = -1;
					}
					//alert(inventorySlide);
				}
				
				if ((event.keyCode == 37) || (event.keyCode == 81)) {
					// Turn Left Q
					
					//if player is in the hole atm, he can not turn around because he is dead.
					if(holeFallen)
						return;
					
					//back tile position modification requires to move front and to the right by half step, then rotate
					var mover = new THREE.Vector3( 0, 0, 0 );
					mover.x = looker.x/2;
					mover.y = looker.y;
					mover.z = looker.z/2;
					camera.position.add(mover);
					mover.normalize();
					//looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					mover.applyMatrix4( matrix );
					if((mover.z<0.0001)&&(mover.z>-0.0001)) mover.z=0;
					if((mover.x<0.0001)&&(mover.x>-0.0001)) mover.x=0;
					mover.x *= 5;
					mover.z *= 5;
					camera.position.add(mover);
					
					//turn west
					looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					looker.applyMatrix4( matrix );
					if((looker.z<0.0001)&&(looker.z>-0.0001)) looker.z=0;
					if((looker.x<0.0001)&&(looker.x>-0.0001)) looker.x=0;
					
					//alert(looker.y);
					//alert();
					looker.x *= 10;
					looker.z *= 10;
					
					var pos = new THREE.Vector3(0, 0, 0);
					pos.x = camera.position.x;
					pos.y = camera.position.y;
					pos.z = camera.position.z;
					//alert(pos.z); 40
					//alert(looker.z); 10
					camera.look = pos.add(looker);
					//alert(pos.z);
					camera.lookAt(camera.look);
				
				} else if ((event.keyCode == 39) || (event.keyCode == 69)) {
					// Turne Right E
					
					//if player is in the hole atm, he can not turn around because he is dead.
					if(holeFallen)
						return;
					
					//back tile position modification requires to move front and to the left by half step, then rotate right
					var mover = new THREE.Vector3( 0, 0, 0 );
					mover.x = looker.x/2;
					mover.y = looker.y;
					mover.z = looker.z/2;
					camera.position.add(mover);
					mover.normalize();
					//looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = +Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					mover.applyMatrix4( matrix );
					if((mover.z<0.0001)&&(mover.z>-0.0001)) mover.z=0;
					if((mover.x<0.0001)&&(mover.x>-0.0001)) mover.x=0;
					mover.x *= 5;
					mover.z *= 5;
					camera.position.add(mover);
					
					//turn west
					looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					looker.applyMatrix4( matrix );
					if((looker.z<0.0001)&&(looker.z>-0.0001)) looker.z=0;
					if((looker.x<0.0001)&&(looker.x>-0.0001)) looker.x=0;
					//alert("pera2 " + looker.x + " " + looker.y + " " + looker.z);
					//alert(looker.y);
					//alert();
					looker.x *= 10;
					looker.z *= 10;
					
					var pos = new THREE.Vector3(0, 0, 0);
					pos.x = camera.position.x;
					pos.y = camera.position.y;
					pos.z = camera.position.z;
					//alert(pos.z); 40
					//alert(looker.z); 10
					camera.look = pos.add(looker);
					//alert(pos.z);
					camera.lookAt(camera.look);
					
				} else if ((event.keyCode == 38) || (event.keyCode == 87)) {
					// Up cursor key or W
					var lookie = new THREE.Vector3(0,0,0).add(looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).add(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.add(looker);
						camera.look.add(looker);
						camera.lookAt(camera.look);
						current_position.add(lookie);
						
						//check if player stepped onto hole in the ground
						if(positionIsHole(new_pos.x, new_pos.z))
						{
							//animate fall into hole
							fallInHole();
						}
					}
				} else if ((event.keyCode == 40) || (event.keyCode == 83)) {
					// Down cursor key or S
					var lookie = new THREE.Vector3(0,0,0).add(looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).sub(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.sub(looker);
						camera.look.sub(looker);
						camera.lookAt(camera.look);
						current_position.sub(lookie);
						
						//check if player stepped onto hole in the ground
						if(positionIsHole(new_pos.x, new_pos.z))
						{
							//animate fall into hole
							fallInHole();
						}
					}
				} else if ((event.keyCode == 37) || (event.keyCode == 65)) {
					// Left cursor key or A
					
					var left_looker = new THREE.Vector3(0, 0, 0).add(looker);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = +Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					left_looker.applyMatrix4( matrix );
					if((left_looker.z<0.0001)&&(left_looker.z>-0.0001)) left_looker.z=0;
					if((left_looker.x<0.0001)&&(left_looker.x>-0.0001)) left_looker.x=0;
					
					var lookie = new THREE.Vector3(0,0,0).add(left_looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).add(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.add(left_looker);
						camera.look.add(left_looker);
						camera.lookAt(camera.look);
						current_position.add(lookie);
						
						//check if player stepped onto hole in the ground
						if(positionIsHole(new_pos.x, new_pos.z))
						{
							//animate fall into hole
							fallInHole();
						}
					}
				} else if ((event.keyCode == 39) || (event.keyCode == 68)) {
					// Right cursor key or D
					
					var right_looker = new THREE.Vector3(0, 0, 0).add(looker);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					right_looker.applyMatrix4( matrix );
					if((right_looker.z<0.0001)&&(right_looker.z>-0.0001)) right_looker.z=0;
					if((right_looker.x<0.0001)&&(right_looker.x>-0.0001)) right_looker.x=0;
					
					var lookie = new THREE.Vector3(0,0,0).add(right_looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).add(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.add(right_looker);
						camera.look.add(right_looker);
						camera.lookAt(camera.look);
						current_position.add(lookie);
						
						//check if player stepped onto hole in the ground
						if(positionIsHole(new_pos.x, new_pos.z))
						{
							//animate fall into hole
							fallInHole();
						}
					}
				}
				
				//alert("pera2 " + looker.x + " " + looker.y + " " + looker.z);
				//alert("pera2 " + camera.position.x + " " + camera.position.y + " " + camera.position.z);
				//camera.position.sub(looker);
				//camera.look.sub(looker);
				//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
				//camera.lookAt(camera.look);
				
			}
	

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				
				//position inventory in the center of screen windowHalfX - (NUM_SLOTS_INVENTORY_ROW/2*SLOT_WIDTH)
				//alert("pera");
				
				inventory_div.style.left = (windowHalfX - (NUM_SLOTS_INVENTORY_ROW/2*SLOT_WIDTH)) +'px';
				//inventory_div.style.top = '100px';

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function loadModel(pos, rot) {
				return function (geometry, materials ) {
					materials[ 0 ].shading = THREE.FlatShading;
					var mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					mesh.position = pos;
					mesh.rotation = rot;
					scene.add( mesh );
				}
			}
			
			function createScene1( geometry, materials ) {

				materials[ 0 ].shading = THREE.FlatShading;

				for(var i=0; i<doorsArr3D.length; i++)
				{
					mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					mesh.position.x = doorsArr3D[i][0]*10;
					mesh.position.z = doorsArr3D[i][1]*10;
					mesh.position.y = 0;
					mesh.rotation.set(0,Math.PI/2, 0);
					mesh.castShadow = true;
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
					scene.add( mesh );
				}
			}
			
			function createScene2( geometry, materials ) {

				materials[ 0 ].shading = THREE.FlatShading;

				for(var i=0; i<doorsArr3D.length; i++)
				{
					doorsArr3D[i][4] = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					doorsArr3D[i][4].position.x = doorsArr3D[i][0]*10;
					doorsArr3D[i][4].position.z = doorsArr3D[i][1]*10;
					doorsArr3D[i][4].position.y = 0;
					doorsArr3D[i][4].rotation.set(0,Math.PI/2, 0);
					doorsArr3D[i][4].castShadow = true;
					doorsArr3D[i][4].scale.x = doorsArr3D[i][4].scale.y = doorsArr3D[i][4].scale.z = 1;
					scene.add( doorsArr3D[i][4] );
				}
			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );
				
				x_pos = event.clientX;
				y_pos = event.clientY;
				
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function handleMouseClick(x,y) {
		
				//is player standing in front of door?
				//currentPos.x, currentPos.z
				var xDoor = 0;
				var zDoor = 0;
				
				//alert("ima1!");
				
				var looker = new THREE.Vector3(0, 0, 0).add(camera.look);
				looker.sub(camera.position);
				looker.normalize();
				var look_pos =new THREE.Vector3(0,0,0).add(current_position);
				look_pos.add(looker);
					
					
				/*if(yaw == 0) {xDoor = currentPos.x; zDoor = currentPos.z-1;}
				if((yaw == 90)||(yaw == -270)) {xDoor = currentPos.x-1; zDoor = currentPos.z}
				if((yaw == 180)||(yaw == -180)) {xDoor = currentPos.x; zDoor = currentPos.z+1;}
				if((yaw == 270)||(yaw == -90)) {xDoor = currentPos.x+1; zDoor = currentPos.z}*/

				for(i=0; i < doorsArr3D.length; i++)
				{
					if((doorsArr3D[i][0] == look_pos.x) && (doorsArr3D[i][1] == look_pos.z))
					{
						//if there are doors in that position..
						/*if((x>450)&&(x<500)&&(y>200)&&(y<250))*/ //location of button
						doorsArr3D[i][5] = 1; //animate flag
						//alert("ima!");
						if(doorsArr3D[i][3] == 0) doorsArr3D[i][3] = 1; // open/close flagww
						else doorsArr3D[i][3] = 0;
					}
				}
			}
			
			
			
			function onMouseClick(event) {

				x_pos = event.clientX;
				y_pos = event.clientY;
				
				//alert("ima1!" + clickConsumed);
				
				// update the mouse variable
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				
				if(pickable_at_hand)
				{
					//alert("yo yo");
					//check if item is placed in inventory
					var slot_index = inventory_clicked_in_slot(x_pos,y_pos);
					if(slot_index > 0)
					{
						//alert("yo yo " + pickable_at_hand);
						add_to_inventory(pickable_at_hand, slot_index);
						pickable_at_hand_icon.style.left = "-170px";
						pickable_at_hand_icon = 0;
						pickable_at_hand = 0;
						
						return;
					}
					else
					{
						//check if player is trying to put it in the niche
						
						//...
						
						
						//drop it on the ground
						//var looker = new THREE.Vector3(0, 0, 0);
						var looker = camera.look.clone().sub(camera.position);
						looker.multiplyScalar(0.8);
						//var pos = camera.position.clone().add(looker);
						pickable_at_hand.mesh.position = camera.position.clone().add(looker);
						pickable_at_hand.mesh.position.y = 0;
						pickable_at_hand.mesh.visible = true;
						pickable_at_hand = 0;

						
						pickable_at_hand_icon.style.left = "-170px";
						pickable_at_hand_icon = 0;
						
						inventorySlide = -1;
						
						return;
					}
				}
				else
				{
					//check if item from inventory is clicked
					if(inventory_div_vertical_pos == INVENTORY_POS_SHOWN)
					{
						var item = inventory_item_clicked(x_pos,y_pos);
						if(item)
						{
							//place inventory item at hand
							pickable_at_hand = item;
							pickable_at_hand.mesh.visible = false;
							pickable_at_hand_icon = document.getElementById("pickable_at_hand_id");
							pickable_at_hand_icon.src = item.icon;
							
							//should we hide inventory right after item pickup?
							//inventorySlide = -1;
							
							//dont do anything else if item is picked
							return;
						}
					}
					
					// create a Ray with origin at the mouse position
					//   and direction into the scene (camera direction)
					var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
					projector.unprojectVector( vector, camera );
					var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

					for (var i=0; i< array_of_pickables.length; i++)
					{
						//first skip buggers that are already picked. they are invisible still laying on the ground and intersection picks them up..
						if(array_of_pickables[i].mesh.visible == false)
							continue;
							
						//check if pickable is clicked on
						var intersects = ray.intersectObject( array_of_pickables[i].mesh );
						
						// if there is one (or more) intersections
						if ( intersects.length > 0 )
						{
							
							// if the closest object intersected is not the currently stored intersection object
							if ( intersects[0].object.id == array_of_pickables[i].id )
							{
								pickable_at_hand = array_of_pickables[i];
								pickable_at_hand.mesh.visible = false;
								pickable_at_hand_icon = document.getElementById("pickable_at_hand_id");
								pickable_at_hand_icon.src = pickable_at_hand.icon;
								//if pickable belongs to niche, remove from niche array
								if(pickable_at_hand.niched > -1) remove_from_niche(pickable_at_hand);
								inventorySlide = 1;
								break;
							}
						}
						else
						{
							//alert("not intersecting!" + array_of_pickables[i].mesh.id);
						}
					}
					
					//pickable_at_hand = array_of_pickables[0].mesh;
					//pickable_at_hand_icon = document.getElementById("pickable_at_hand_id");
					//pickable_at_hand_icon.src = "media/healing.png";
					
					
//					alert("pera " + pos.x + " " + pos.y + " " + pos.z);
				}
				
				//var canvas = document.getElementById('webglcanvas');
				//var rect = canvas.getBoundingClientRect();// check if your browser supports this
				//alert( rect.bottom );
				//if((x_pos > rect.left) && (x_pos < rect.right) && (y_pos > rect.top) && (y_pos < rect.bottom))
				{
					//y_pos = rect.bottom - y_pos;
					//x_pos = x_pos - rect.left;
					handleMouseClick(x_pos, y_pos);
				}
				
			}
	
			//

			    var lastTime = 0;

    //function animate() {
        
    //}

	
			function animate() {

				requestAnimationFrame( animate );

				var timeNow = new Date().getTime();
				
				//..so it begins
				if (lastTime != 0) {

					var elapsed = timeNow - lastTime;

					//animate doors opening/closing
					for(i=0; i < doorsArr3D.length; i++)
					{
						if(doorsArr3D[i][5] == 1)
						{
							if(doorsArr3D[i][3] == 0) 
							{
								doorsArr3D[i][4].position.y -= elapsed/800;
								if(doorsArr3D[i][4].position.y < 0.01) 
								{
									doorsArr3D[i][5] = 0;
								}
							}
							else 
							{
								doorsArr3D[i][4].position.y += elapsed/800;
								if(doorsArr3D[i][4].position.y > 7.5) 
								{
									doorsArr3D[i][5] = 0;
								}
							}
						}
					}
					
					
					//slide inventory up
					if(inventorySlide == 1)
					{
						inventory_div_vertical_pos += elapsed/3;
						inventory_div.style.bottom = inventory_div_vertical_pos + 'px';
						//alert(inventory_div.style.bottom);
						if(inventory_div_vertical_pos > INVENTORY_POS_SHOWN)
						{
							inventory_div.style.bottom = INVENTORY_POS_SHOWN + 'px';
							inventory_div_vertical_pos = INVENTORY_POS_SHOWN;
							inventorySlide = 0;
						}
						//inventory_div.style.top = '100px';
					}
					if(inventorySlide == -1)
					{
						inventory_div_vertical_pos -= elapsed/3;
						inventory_div.style.bottom = inventory_div_vertical_pos +'px';
						//alert(inventory_div.style.bottom);
						if(inventory_div_vertical_pos < INVENTORY_POS_HIDDEN)
						{
							inventory_div.style.bottom = INVENTORY_POS_HIDDEN + 'px';
							inventory_div_vertical_pos = INVENTORY_POS_HIDDEN;
							inventorySlide = 0;
						}
						//inventory_div.style.top = '100px';
					}
					
					
					//animate hole fall
					if(holeFallen)
					{
						if(camera.position.y > -6)
						{
							var looker = camera.look.clone().sub(camera.position);
							camera.position.x += elapsed*looker.x/1200;
							camera.position.z += elapsed*looker.z/1200;
							camera.position.y -= elapsed/40;
							camera.look.y += elapsed/60;
							camera.lookAt(camera.look);
						}
						else if(!alerted)
						{
							alerted = true;
							alert("game over");
						}
					}
					
				}
				lastTime = timeNow;
		
		
				/*
				//move pickable 3d object on the screen under mouse
				if(pickable_at_hand)
				{
					var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
					projector.unprojectVector( vector, camera );
					var dir = vector.sub( camera.position ).normalize();
					dir.multiplyScalar( 10 );
					var pos = camera.position.clone().add( dir );
					pickable_at_hand.mesh.position = pos;
					//alert("pickable_at_hand oooo" + pickable_at_hand);	
				}*/
				
				if(pickable_at_hand_icon)
				{
					pickable_at_hand_icon.style.left = (x_pos - 64) + 'px';
					pickable_at_hand_icon.style.top = (y_pos - 64) + 'px';
				}
		
		
				render();
				
				
				
				
	
	
	

			}

			function render() {


				renderer.render( scene, camera );

			}

		</script>

		<img id="pickable_at_hand_id" src="none.png" style="position:absolute; left:-170px;" />
		
	</body>
</html>
