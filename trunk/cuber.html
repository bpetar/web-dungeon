<!DOCTYPE html>
<html lang="en">
	<head>
		<title>cuber</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #eee;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>

		<script src="./source/three.min.js"></script>

		<script>


			var SQUARE_SIZE = 10;

			var floorsArr2D = [[4,0], [4,1], [4,2], [4,3], [4,4], [4,5], [5,2], [6,2], [6,3], [6,4], [3,2], [2,2], [2,3], [2,4], [2,5]];
			var wallsArr2D = [];
			var doorsArr3D = [[4,3,0,0,0], [2,3,0,0,0], [6,3,0,0,0]]; //x,z,rot,open,y sliding pos, 

			var container;

			var camera, scene, renderer;

			var mesh, mesh2, mesh3, light;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function createWallsFromFloors() {
				var i = 0;
				var j = 0;
				var k = 0;
				//alert(floorsArr2D.length);
				for(i=0; i < floorsArr2D.length; i++)
				{
					var leftWall = true;
					var rightWall = true;
					var frontWall = true;
					var backWall = true;
					var xTile = floorsArr2D[i][0];
					var yTile = floorsArr2D[i][1];
					//make walls around floor tile, but check if it has neighboring tile..
					for(j=0; j < floorsArr2D.length; j++)
					{
						if(i!=j)
						{
							if((floorsArr2D[j][0] == xTile-1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the left - no LeftWall.
								leftWall = false;
							}
							if((floorsArr2D[j][0] == xTile+1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the right - no RightWall.
								rightWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile+1))
							{
								//there is floor tile to the front - no FrontWall.
								frontWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile-1))
							{
								//there is floor tile to the back - no BackWall.
								backWall = false;
							}
						}
					}
					
					if(leftWall)
					{
						wallsArr2D[k] = [xTile,yTile,xTile,yTile+1];
						k++;
					}
					if(rightWall)
					{
						wallsArr2D[k] = [xTile+1,yTile,xTile+1,yTile+1];
						k++;
					}
					if(frontWall)
					{
						wallsArr2D[k] = [xTile,yTile+1,xTile+1,yTile+1];
						k++;
					}
					if(backWall)
					{
						wallsArr2D[k] = [xTile,yTile,xTile+1,yTile];
						k++;
					}
				}
			}
			function init() {

				container = document.getElementById( 'container' );
				
				createWallsFromFloors();
				
				document.onkeydown = handleKeyDown;

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.x = 40;
				camera.position.y = 5;
				camera.position.z = -5;
				camera.look = new THREE.Vector3(40,5,10);
				camera.lookAt(camera.look);

				scene = new THREE.Scene();

				light = new THREE.SpotLight();
				light.position.set( -40, 60, 40 );
				light.castShadow = true;
				scene.add( light );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( 50, 50, 50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( -50, -50, -50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );

				var loader = new THREE.JSONLoader();

				loader.load( "models/tost.js", createScene1 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMapWidth = 128;;
				renderer.shadowMapHeight = 128;
				renderer.shadowCameraFov = 50;

				container.appendChild( renderer.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				var map = THREE.ImageUtils.loadTexture( 'media/floor.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

				var material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );

				//floors
				for(var i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//ceiling
				
				map = THREE.ImageUtils.loadTexture( 'media/ceiling.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0.8*SQUARE_SIZE; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//walls
				
				map = THREE.ImageUtils.loadTexture( 'media/wall.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					var leftWall = true;
					var rightWall = true;
					var frontWall = true;
					var backWall = true;
					var xTile = floorsArr2D[i][0];
					var yTile = floorsArr2D[i][1];
					//make walls around floor tile, but check if it has neighboring tile..
					for(j=0; j < floorsArr2D.length; j++)
					{
						if(i!=j)
						{
							if((floorsArr2D[j][0] == xTile+1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the left - no LeftWall.
								leftWall = false;
							}
							if((floorsArr2D[j][0] == xTile-1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the right - no RightWall.
								rightWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile+1))
							{
								//there is floor tile to the front - no FrontWall.
								frontWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile-1))
							{
								//there is floor tile to the back - no BackWall.
								backWall = false;
							}
						}
					}
					
					if(leftWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI/2, 0);
						object.receiveShadow = true;
						
					
						object.position.x = (floorsArr2D[i][0]+0.5)*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(rightWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI/2, 0);
						object.receiveShadow = true;
						
					
						object.position.x = (floorsArr2D[i][0]-0.5)*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(frontWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1]+0.5)*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(backWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1]-0.5)*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					
					
				}
  
				renderer.shadowMapEnabled = true;

			}

			function handleKeyDown(event) {
				//alert(event.keyCode);
				//if (event.keyCode == 88) {animateDoor = true;}
				
				//Movement:
				var looker = new THREE.Vector3(0, 0, 0);
				looker.x = camera.look.x;
				looker.y = camera.look.y;
				looker.z = camera.look.z;
					
				looker.sub(camera.position);
				
				
				
				if (event.keyCode == 81) {
					// Turn Left Q
					//if(looker.z>0) //looking north
					
					//back tile position modification requires to move front and to the right by half step, then rotate
					var mover = new THREE.Vector3( 0, 0, 0 );
					mover.x = looker.x/2;
					mover.y = looker.y;
					mover.z = looker.z/2;
					camera.position.add(mover);
					mover.normalize();
					//looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					mover.applyMatrix4( matrix );
					if((mover.z<0.0001)&&(mover.z>-0.0001)) mover.z=0;
					if((mover.x<0.0001)&&(mover.x>-0.0001)) mover.x=0;
					mover.x *= 5;
					mover.z *= 5;
					camera.position.add(mover);
					
					//turn west
					looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					looker.applyMatrix4( matrix );
					if((looker.z<0.0001)&&(looker.z>-0.0001)) looker.z=0;
					if((looker.x<0.0001)&&(looker.x>-0.0001)) looker.x=0;
					
					//alert(looker.y);
					//alert();
					looker.x *= 10;
					looker.z *= 10;
					
					var pos = new THREE.Vector3(0, 0, 0);
					pos.x = camera.position.x;
					pos.y = camera.position.y;
					pos.z = camera.position.z;
					//alert(pos.z); 40
					//alert(looker.z); 10
					camera.look = pos.add(looker);
					//alert(pos.z);
					camera.lookAt(camera.look);
				
				} else if (event.keyCode == 69) {
					// Turne Right E
					
					//turn west
					looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					looker.applyMatrix4( matrix );
					if((looker.z<0.0001)&&(looker.z>-0.0001)) looker.z=0;
					if((looker.x<0.0001)&&(looker.x>-0.0001)) looker.x=0;
					//alert("pera2 " + looker.x + " " + looker.y + " " + looker.z);
					//alert(looker.y);
					//alert();
					looker.x *= 10;
					looker.z *= 10;
					
					var pos = new THREE.Vector3(0, 0, 0);
					pos.x = camera.position.x;
					pos.y = camera.position.y;
					pos.z = camera.position.z;
					//alert(pos.z); 40
					//alert(looker.z); 10
					camera.look = pos.add(looker);
					//alert(pos.z);
					camera.lookAt(camera.look);
					
				} else if ((event.keyCode == 38) || (event.keyCode == 87)) {
					// Up cursor key or W
					
					camera.position.add(looker);
					//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
					camera.look.add(looker);
					//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
					camera.lookAt(camera.look);
				} else if ((event.keyCode == 40) || (event.keyCode == 83)) {
					// Down cursor key or S
					
					camera.position.sub(looker);
					//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
					camera.look.sub(looker);
					//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
					camera.lookAt(camera.look);
				} else if ((event.keyCode == 37) || (event.keyCode == 65)) {
					// Left cursor key or A
					
					var left_pos_offset = new THREE.Vector3(0, 0, 0);
					left_pos_offset.x = looker.x;
					left_pos_offset.y = looker.y;
					left_pos_offset.z = looker.z;
					left_pos_offset.normalize();
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = +Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					left_pos_offset.applyMatrix4( matrix );
					if((left_pos_offset.z<0.0001)&&(left_pos_offset.z>-0.0001)) left_pos_offset.z=0;
					if((left_pos_offset.x<0.0001)&&(left_pos_offset.x>-0.0001)) left_pos_offset.x=0;
					left_pos_offset.x *= 10;
					left_pos_offset.z *= 10;
					
					camera.position.add(left_pos_offset);
					camera.look.add(left_pos_offset);
					camera.lookAt(camera.look);
				} else if ((event.keyCode == 39) || (event.keyCode == 68)) {
					// Right cursor key or D
					
					var right_pos_offset = new THREE.Vector3(0, 0, 0);
					right_pos_offset.x = looker.x;
					right_pos_offset.y = looker.y;
					right_pos_offset.z = looker.z;
					right_pos_offset.normalize();
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					right_pos_offset.applyMatrix4( matrix );
					if((right_pos_offset.z<0.0001)&&(right_pos_offset.z>-0.0001)) right_pos_offset.z=0;
					if((right_pos_offset.x<0.0001)&&(right_pos_offset.x>-0.0001)) right_pos_offset.x=0;
					right_pos_offset.x *= 10;
					right_pos_offset.z *= 10;
					
					camera.position.add(right_pos_offset);
					camera.look.add(right_pos_offset);
					camera.lookAt(camera.look);
				}
				
				//alert("pera2 " + looker.x + " " + looker.y + " " + looker.z);
				//alert("pera2 " + camera.position.x + " " + camera.position.y + " " + camera.position.z);
				//camera.position.sub(looker);
				//camera.look.sub(looker);
				//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
				//camera.lookAt(camera.look);
				
			}
	

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createScene1( geometry, materials ) {

				materials[ 0 ].shading = THREE.FlatShading;

				for(var i=0; i<10; i++)
				{
				mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
				mesh.position.x = 0;
				mesh.castShadow = true;
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
				
				
					mesh.position.x = -100 + i*10;
					scene.add( mesh );
				}
			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {


				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
