<!DOCTYPE html>
<html lang="en">
	<head>
		<title>cuber</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #eee;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>

		<script src="./source/three.min.js"></script>

		<script>


			var SQUARE_SIZE = 10;

			var floorsArr2D = [[4,0], [4,1], [4,2], [4,3], [4,4], [4,5], [5,2], [6,2], [6,3], [6,4], [6,4], [3,2], [2,2], [2,3], [2,4], [2,5]];
			var wallsArr2D = [];
			var doorsArr3D = [[4,3,0,0,0], [2,3,0,0,0], [6,3,0,0,0]]; //x,z,rot,open,y sliding pos, 

			var container;

			var camera, scene, renderer;

			var mesh, mesh2, mesh3, light;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function createWallsFromFloors() {
				var i = 0;
				var j = 0;
				var k = 0;
				//alert(floorsArr2D.length);
				for(i=0; i < floorsArr2D.length; i++)
				{
					var leftWall = true;
					var rightWall = true;
					var frontWall = true;
					var backWall = true;
					var xTile = floorsArr2D[i][0];
					var yTile = floorsArr2D[i][1];
					//make walls around floor tile, but check if it has neighboring tile..
					for(j=0; j < floorsArr2D.length; j++)
					{
						if(i!=j)
						{
							if((floorsArr2D[j][0] == xTile-1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the left - no LeftWall.
								leftWall = false;
							}
							if((floorsArr2D[j][0] == xTile+1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the right - no RightWall.
								rightWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile+1))
							{
								//there is floor tile to the front - no FrontWall.
								frontWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile-1))
							{
								//there is floor tile to the back - no BackWall.
								backWall = false;
							}
						}
					}
					
					if(leftWall)
					{
						wallsArr2D[k] = [xTile,yTile,xTile,yTile+1];
						k++;
					}
					if(rightWall)
					{
						wallsArr2D[k] = [xTile+1,yTile,xTile+1,yTile+1];
						k++;
					}
					if(frontWall)
					{
						wallsArr2D[k] = [xTile,yTile+1,xTile+1,yTile+1];
						k++;
					}
					if(backWall)
					{
						wallsArr2D[k] = [xTile,yTile,xTile+1,yTile];
						k++;
					}
				}
			}
			function init() {

				container = document.getElementById( 'container' );
				
				createWallsFromFloors();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.x = 40;
				camera.position.y = 5;
				camera.position.z = 0;

				scene = new THREE.Scene();

				light = new THREE.SpotLight();
				light.position.set( -40, 60, 40 );
				light.castShadow = true;
				scene.add( light );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( 50, 50, 50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( -50, -50, -50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );

				var loader = new THREE.JSONLoader();

				loader.load( "models/tost.js", createScene1 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMapWidth = 128;;
				renderer.shadowMapHeight = 128;
				renderer.shadowCameraFov = 50;

				container.appendChild( renderer.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				var map = THREE.ImageUtils.loadTexture( 'media/floor.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

				var material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );

				//floors
				for(var i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//ceiling
				
				map = THREE.ImageUtils.loadTexture( 'media/ceiling.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0.8*SQUARE_SIZE; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//walls
				
				map = THREE.ImageUtils.loadTexture( 'media/wall.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					var leftWall = true;
					var rightWall = true;
					var frontWall = true;
					var backWall = true;
					var xTile = floorsArr2D[i][0];
					var yTile = floorsArr2D[i][1];
					//make walls around floor tile, but check if it has neighboring tile..
					for(j=0; j < floorsArr2D.length; j++)
					{
						if(i!=j)
						{
							if((floorsArr2D[j][0] == xTile-1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the left - no LeftWall.
								leftWall = false;
							}
							if((floorsArr2D[j][0] == xTile+1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the right - no RightWall.
								rightWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile+1))
							{
								//there is floor tile to the front - no FrontWall.
								frontWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile-1))
							{
								//there is floor tile to the back - no BackWall.
								backWall = false;
							}
						}
					}
					
					if(leftWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI/2, 0);
						object.receiveShadow = true;
						
					
						object.position.x = (floorsArr2D[i][0]+0.5)*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(rightWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI/2, 0);
						object.receiveShadow = true;
						
					
						object.position.x = (floorsArr2D[i][0]-0.5)*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(frontWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1]+0.5)*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(backWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1]-0.5)*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					
					
				}
  
				renderer.shadowMapEnabled = true;

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createScene1( geometry, materials ) {

				materials[ 0 ].shading = THREE.FlatShading;

				for(var i=0; i<10; i++)
				{
				mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
				mesh.position.x = 0;
				mesh.castShadow = true;
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
				
				
					mesh.position.x = -100 + i*10;
					scene.add( mesh );
				}
			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				//camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				//camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				//camera.lookAt( scene.position );
				//camera.lookAt.x = 40;
				camera.lookAt(new THREE.Vector3(40,5,10));

				if ( mesh ) {

					//mesh.rotation.x += 0.01;
					mesh.rotation.y += 0.01;
				}

				if ( mesh2 ) {

					//mesh2.rotation.x += 0.01;
					//mesh2.rotation.y += 0.01;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
