<!DOCTYPE html>
<html lang="en">
	<head>
		<title>cuber</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #eee;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container" style="position:absolute;"></div>
		<div id="gui" style="position:absolute; left:70px; top:70px;">
			<div id="player1" style="border:2px solid;">
				<div id="player1top" style="border:1px solid red; float: left;">
					<div id="player1topimg" style="float: left;">
					<img src="media/profile1.jpg" onClick='inventory_show("Inventory will popup here!")'> 
					</div>
					<div id="player1tophand" style="margin-left: 110px;">
					<img src="media/health.png"> 
					<br>
					<img src="media/mace.png" onClick='alert("Smash!")'> 
					</div>
				</div>
				<br>
				Drn Inatdzija
			</div>
		<br>
		<br>
			<div id="player2" style="border:2px solid;">
				<div id="player1top" style="border:1px solid red; float: left;">
					<div id="player1topimg" style="float: left;">
					<img src="media/profile2.jpg" onClick='inventory_show("Inventory will popup here!")'> 
					</div>
					<div id="player1tophand" style="margin-left: 110px;">
					<img src="media/health.png"> 
					<br>
					<img src="media/staff.png" onClick='alert("Swing!")'> 
					</div>
				</div>
				<br>
				Mech Cloaker
			</div>
		</div>
		<div id="inventory" style="display:none; position:absolute; left:310px; top:70px;">
			<img src="media/inventory.png" onClick='hide("Inventory not yet implemented!")'> 
		</div>

		<script src="./source/pickables.js"></script>
		<script src="./source/game_object.js"></script>
		<script src="./source/three.min.js"></script>

		<script>
		
			clickConsumed = false;

			function inventory_show(param) {
				//alert(param + clickConsumed);
				//clickConsumed = true;
				var ele = document.getElementById("inventory");
				ele.style.display = "block";
			}
			
			function hide(param) {
				alert(param);
				//clickConsumed = true;
				var ele = document.getElementById("inventory");
				ele.style.display = "none";
			}

			var SQUARE_SIZE = 10;

			var floorsArr2D = [[4,0], [4,1], [4,2], [4,3], [4,4], [4,5], [5,2], [6,2], [6,3], [6,4], [3,2], [2,2], [2,3], [2,4], [2,5]];
			//var wallsArr2D = [];
			var doorsArr3D = [[4,3,0,0,0], [2,3,0,0,0], [6,3,0,0,0]]; //x,z,rot,open,mesh, 

			var container;
			
			var pickable_at_hand;
			var pickable_at_hand_icon;
			
						var projector, mouse = { x: 0, y: 0 }, INTERSECTED;


			var camera, scene, renderer;

			var mesh, mesh2, mesh3, light;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var current_position;
			
			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );
				
				//createWallsFromFloors();
				
				document.onkeydown = handleKeyDown;

				camera = new THREE.PerspectiveCamera( 47, window.innerWidth / window.innerHeight, .1, 10000 );
				camera.position.x = 40;
				camera.position.y = 4;
				camera.position.z = -5;
				camera.look = new THREE.Vector3(40,4,5);
				camera.lookAt(camera.look);
				
				current_position = new THREE.Vector3(4,0,0);

				scene = new THREE.Scene();

				light = new THREE.SpotLight();
				light.position.set( -40, 60, 40 );
				light.castShadow = true;
				scene.add( light );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( 50, 50, 50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );
				
				light2 = new THREE.DirectionalLight( 0xffffff );
				light2.position.set( -50, -50, -50 ).normalize();
				light2.castShadow = true;
				scene.add( light2 );

				//load pickables
				load_pickables();
				
				var loader = new THREE.JSONLoader();

				//loader.load( "models/tost.js", createScene1 );
				loader.load( "models/doorway.js", createScene1 );
				loader.load( "models/door.js", createScene2 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMapWidth = 128;;
				renderer.shadowMapHeight = 128;
				renderer.shadowCameraFov = 50;

				container.appendChild( renderer.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onMouseClick, false );

				//
				/////// draw text on canvas /////////

				// create a canvas element
				var canvas1 = document.createElement('canvas');
				var context1 = canvas1.getContext('2d');
				context1.font = "Bold 20px Arial";
				//context1.fillStyle = "rgba(1,1,0,0.95)";
				//context1.fillText('Hello, world!', 10, 20);
				
				context1.clearRect(0,0,640,480);
				var message = "Pera";
				var metrics = context1.measureText(message);
				var width = metrics.width;
				context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
				context1.fillRect( 0,0, width+8,20+8);
				context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
				context1.fillRect( 2,2, width+4,20+4 );
				context1.fillStyle = "rgba(0,0,0,1)"; // text color
				context1.fillText( message, 4,20 );
				
				// canvas contents will be used for a texture
				var texture1 = new THREE.Texture(canvas1) 
				texture1.needsUpdate = true;
				
				////////////////////////////////////////
				
				var spriteMaterial = new THREE.SpriteMaterial( { map: texture1, useScreenCoordinates: true, alignment: THREE.SpriteAlignment.topLeft } );
				
				var sprite1 = new THREE.Sprite( spriteMaterial );
				sprite1.scale.set(200,200,1.0);
				sprite1.position.set( 50, 15, 0 );
				scene.add( sprite1 );	
				
				/////// draw text on canvas /////////
				
				// initialize object to perform world/screen calculations
				projector = new THREE.Projector();


				window.addEventListener( 'resize', onWindowResize, false );

				var map = THREE.ImageUtils.loadTexture( 'media/floor.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

				var material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );

				//floors
				for(var i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//ceiling
				
				map = THREE.ImageUtils.loadTexture( 'media/ceiling.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, SQUARE_SIZE, 1, 1 ), material );
					//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
					object.rotation.set(-Math.PI/2, 0, 0);
					object.receiveShadow = true;
					
				
					object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
					object.position.y = 0.8*SQUARE_SIZE; //y
					object.position.z = floorsArr2D[i][1]*SQUARE_SIZE; //z
			
					//alert(object.position.x);
					scene.add( object );
				}
				
				//walls
				
				map = THREE.ImageUtils.loadTexture( 'media/wall.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;
				material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
				for(i=0; i < floorsArr2D.length; i++)
				{
					var leftWall = true;
					var rightWall = true;
					var frontWall = true;
					var backWall = true;
					var xTile = floorsArr2D[i][0];
					var yTile = floorsArr2D[i][1];
					//make walls around floor tile, but check if it has neighboring tile..
					for(j=0; j < floorsArr2D.length; j++)
					{
						if(i!=j)
						{
							if((floorsArr2D[j][0] == xTile+1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the left - no LeftWall.
								leftWall = false;
							}
							if((floorsArr2D[j][0] == xTile-1) && (floorsArr2D[j][1] == yTile))
							{
								//there is floor tile to the right - no RightWall.
								rightWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile+1))
							{
								//there is floor tile to the front - no FrontWall.
								frontWall = false;
							}
							if((floorsArr2D[j][0] == xTile) && (floorsArr2D[j][1] == yTile-1))
							{
								//there is floor tile to the back - no BackWall.
								backWall = false;
							}
						}
					}
					
					if(leftWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI/2, 0);
						object.receiveShadow = true;
						
					
						object.position.x = (floorsArr2D[i][0]+0.5)*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(rightWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI/2, 0);
						object.receiveShadow = true;
						
					
						object.position.x = (floorsArr2D[i][0]-0.5)*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1])*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(frontWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1]+0.5)*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					if(backWall)
					{
						object = new THREE.Mesh( new THREE.PlaneGeometry( SQUARE_SIZE, 0.8*SQUARE_SIZE, 1, 1 ), material );
						//object.position.set( 0-i*SQUARE_SIZE, -1, 0 );
						object.rotation.set(0, Math.PI, 0);
						object.receiveShadow = true;
						
					
						object.position.x = floorsArr2D[i][0]*SQUARE_SIZE; //x
						object.position.y = 0.4*SQUARE_SIZE; //y
						object.position.z = (floorsArr2D[i][1]-0.5)*SQUARE_SIZE; //z
				
						//alert(object.position.x);
						scene.add( object );
					}
					
					
				}
  
				renderer.shadowMapEnabled = true;

			}

			//decide weather step is possible (hitting walls)
			function canMoveTo(x, z)
			{
				var i = 0;
				var j = 0;
				
				//alert("pera " + x + " " + z);
				for(i=0; i < floorsArr2D.length; i++)
				{
					if((floorsArr2D[i][0] == x) && (floorsArr2D[i][1] == z))
					{
						for(j=0; j < doorsArr3D.length; j++)
						{
							//if there are closed doors in that position..
							if((doorsArr3D[j][0] == x) && (doorsArr3D[j][1] == z)) 
							{
								if(doorsArr3D[j][3] == 0) return false;
							}
						}
						return true;
					}
				}
				return false;
			}

			//
			function handleKeyDown(event) {
				//alert(event.keyCode);
				//if (event.keyCode == 88) {animateDoor = true;}
				
				//Movement:
				var looker = new THREE.Vector3(0, 0, 0);
				looker.x = camera.look.x;
				looker.y = camera.look.y;
				looker.z = camera.look.z;
					
				looker.sub(camera.position);
				
				
				
				if (event.keyCode == 81) {
					// Turn Left Q
					//if(looker.z>0) //looking north
					
					//back tile position modification requires to move front and to the right by half step, then rotate
					var mover = new THREE.Vector3( 0, 0, 0 );
					mover.x = looker.x/2;
					mover.y = looker.y;
					mover.z = looker.z/2;
					camera.position.add(mover);
					mover.normalize();
					//looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					mover.applyMatrix4( matrix );
					if((mover.z<0.0001)&&(mover.z>-0.0001)) mover.z=0;
					if((mover.x<0.0001)&&(mover.x>-0.0001)) mover.x=0;
					mover.x *= 5;
					mover.z *= 5;
					camera.position.add(mover);
					
					//turn west
					looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					looker.applyMatrix4( matrix );
					if((looker.z<0.0001)&&(looker.z>-0.0001)) looker.z=0;
					if((looker.x<0.0001)&&(looker.x>-0.0001)) looker.x=0;
					
					//alert(looker.y);
					//alert();
					looker.x *= 10;
					looker.z *= 10;
					
					var pos = new THREE.Vector3(0, 0, 0);
					pos.x = camera.position.x;
					pos.y = camera.position.y;
					pos.z = camera.position.z;
					//alert(pos.z); 40
					//alert(looker.z); 10
					camera.look = pos.add(looker);
					//alert(pos.z);
					camera.lookAt(camera.look);
				
				} else if (event.keyCode == 69) {
					// Turne Right E
					
					//back tile position modification requires to move front and to the left by half step, then rotate right
					var mover = new THREE.Vector3( 0, 0, 0 );
					mover.x = looker.x/2;
					mover.y = looker.y;
					mover.z = looker.z/2;
					camera.position.add(mover);
					mover.normalize();
					//looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = +Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					mover.applyMatrix4( matrix );
					if((mover.z<0.0001)&&(mover.z>-0.0001)) mover.z=0;
					if((mover.x<0.0001)&&(mover.x>-0.0001)) mover.x=0;
					mover.x *= 5;
					mover.z *= 5;
					camera.position.add(mover);
					
					//turn west
					looker.normalize();
					//alert("pera1 " + looker.x + " " + looker.y + " " + looker.z);
					//looker.rotate(Math.PI/2);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					looker.applyMatrix4( matrix );
					if((looker.z<0.0001)&&(looker.z>-0.0001)) looker.z=0;
					if((looker.x<0.0001)&&(looker.x>-0.0001)) looker.x=0;
					//alert("pera2 " + looker.x + " " + looker.y + " " + looker.z);
					//alert(looker.y);
					//alert();
					looker.x *= 10;
					looker.z *= 10;
					
					var pos = new THREE.Vector3(0, 0, 0);
					pos.x = camera.position.x;
					pos.y = camera.position.y;
					pos.z = camera.position.z;
					//alert(pos.z); 40
					//alert(looker.z); 10
					camera.look = pos.add(looker);
					//alert(pos.z);
					camera.lookAt(camera.look);
					
				} else if ((event.keyCode == 38) || (event.keyCode == 87)) {
					// Up cursor key or W
					var lookie = new THREE.Vector3(0,0,0).add(looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).add(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.add(looker);
						camera.look.add(looker);
						camera.lookAt(camera.look);
						current_position.add(lookie);
					}
				} else if ((event.keyCode == 40) || (event.keyCode == 83)) {
					// Down cursor key or S
					var lookie = new THREE.Vector3(0,0,0).add(looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).sub(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.sub(looker);
						camera.look.sub(looker);
						camera.lookAt(camera.look);
						current_position.sub(lookie);
					}
				} else if ((event.keyCode == 37) || (event.keyCode == 65)) {
					// Left cursor key or A
					
					var left_looker = new THREE.Vector3(0, 0, 0).add(looker);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = +Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					left_looker.applyMatrix4( matrix );
					if((left_looker.z<0.0001)&&(left_looker.z>-0.0001)) left_looker.z=0;
					if((left_looker.x<0.0001)&&(left_looker.x>-0.0001)) left_looker.x=0;
					
					var lookie = new THREE.Vector3(0,0,0).add(left_looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).add(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.add(left_looker);
						camera.look.add(left_looker);
						camera.lookAt(camera.look);
						current_position.add(lookie);
					}
				} else if ((event.keyCode == 39) || (event.keyCode == 68)) {
					// Right cursor key or D
					
					var right_looker = new THREE.Vector3(0, 0, 0).add(looker);
					var axis = new THREE.Vector3( 0, 1, 0 );
					var angle = -Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
					right_looker.applyMatrix4( matrix );
					if((right_looker.z<0.0001)&&(right_looker.z>-0.0001)) right_looker.z=0;
					if((right_looker.x<0.0001)&&(right_looker.x>-0.0001)) right_looker.x=0;
					
					var lookie = new THREE.Vector3(0,0,0).add(right_looker);
					lookie.normalize();
					var new_pos =new THREE.Vector3(0,0,0).add(lookie);
					new_pos.add(current_position);
					if(canMoveTo(new_pos.x, new_pos.z))
					{
						camera.position.add(right_looker);
						camera.look.add(right_looker);
						camera.lookAt(camera.look);
						current_position.add(lookie);
					}
				}
				
				//alert("pera2 " + looker.x + " " + looker.y + " " + looker.z);
				//alert("pera2 " + camera.position.x + " " + camera.position.y + " " + camera.position.z);
				//camera.position.sub(looker);
				//camera.look.sub(looker);
				//alert("pera2 " + camera.look.x + " " + camera.look.y + " " + camera.look.z);
				//camera.lookAt(camera.look);
				
			}
	

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createScene1( geometry, materials ) {

				materials[ 0 ].shading = THREE.FlatShading;

				for(var i=0; i<doorsArr3D.length; i++)
				{
					mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					mesh.position.x = doorsArr3D[i][0]*10;
					mesh.position.z = doorsArr3D[i][1]*10;
					mesh.position.y = 0;
					mesh.rotation.set(0,Math.PI/2, 0);
					mesh.castShadow = true;
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
					scene.add( mesh );
				}
			}
			
			function createScene2( geometry, materials ) {

				materials[ 0 ].shading = THREE.FlatShading;

				for(var i=0; i<doorsArr3D.length; i++)
				{
					doorsArr3D[i][4] = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					doorsArr3D[i][4].position.x = doorsArr3D[i][0]*10;
					doorsArr3D[i][4].position.z = doorsArr3D[i][1]*10;
					doorsArr3D[i][4].position.y = 0;
					doorsArr3D[i][4].rotation.set(0,Math.PI/2, 0);
					doorsArr3D[i][4].castShadow = true;
					doorsArr3D[i][4].scale.x = doorsArr3D[i][4].scale.y = doorsArr3D[i][4].scale.z = 1;
					scene.add( doorsArr3D[i][4] );
				}
			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );
				
				x_pos = event.clientX;
				y_pos = event.clientY;
				
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function handleMouseClick(x,y) {
		
				//is player standing in front of door?
				//currentPos.x, currentPos.z
				var xDoor = 0;
				var zDoor = 0;
				
				//alert("ima1!");
				
				var looker = new THREE.Vector3(0, 0, 0).add(camera.look);
				looker.sub(camera.position);
				looker.normalize();
				var look_pos =new THREE.Vector3(0,0,0).add(current_position);
				look_pos.add(looker);
					
					
				/*if(yaw == 0) {xDoor = currentPos.x; zDoor = currentPos.z-1;}
				if((yaw == 90)||(yaw == -270)) {xDoor = currentPos.x-1; zDoor = currentPos.z}
				if((yaw == 180)||(yaw == -180)) {xDoor = currentPos.x; zDoor = currentPos.z+1;}
				if((yaw == 270)||(yaw == -90)) {xDoor = currentPos.x+1; zDoor = currentPos.z}*/

				for(i=0; i < doorsArr3D.length; i++)
				{
					if((doorsArr3D[i][0] == look_pos.x) && (doorsArr3D[i][1] == look_pos.z))
					{
						//if there are doors in that position..
						/*if((x>450)&&(x<500)&&(y>200)&&(y<250))*/ //location of button
						doorsArr3D[i][5] = 1; //animate flag
						//alert("ima!");
						if(doorsArr3D[i][3] == 0) doorsArr3D[i][3] = 1; // open/close flag
						else doorsArr3D[i][3] = 0;
					}
				}
			}
			
			

			
			function onMouseClick(event) {

				x_pos = event.clientX;
				y_pos = event.clientY;
				
				//alert("ima1!" + clickConsumed);
				
				// update the mouse variable
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				
				if(event.clientX > 800)
				{
					pickable_at_hand = array_of_pickables[0].mesh;
					pickable_at_hand_icon = document.getElementById("pickable_at_hand_id");
					pickable_at_hand_icon.src = "media/healing.png";
					
					
//					alert("pera " + pos.x + " " + pos.y + " " + pos.z);
				}
				
				//var canvas = document.getElementById('webglcanvas');
				//var rect = canvas.getBoundingClientRect();// check if your browser supports this
				//alert( rect.bottom );
				//if((x_pos > rect.left) && (x_pos < rect.right) && (y_pos > rect.top) && (y_pos < rect.bottom))
				{
					//y_pos = rect.bottom - y_pos;
					//x_pos = x_pos - rect.left;
					handleMouseClick(x_pos, y_pos);
				}
				
			}
	
			//

			    var lastTime = 0;

    //function animate() {
        
    //}

	
			function animate() {

				requestAnimationFrame( animate );

				
				
				var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

			for(i=0; i < doorsArr3D.length; i++)
			{
				if(doorsArr3D[i][5] == 1)
				{
					if(doorsArr3D[i][3] == 0) 
					{
						doorsArr3D[i][4].position.y -= elapsed/800;
						if(doorsArr3D[i][4].position.y < 0.01) 
						{
							doorsArr3D[i][5] = 0;
						}
					}
					else 
					{
						doorsArr3D[i][4].position.y += elapsed/800;
						if(doorsArr3D[i][4].position.y > 7.5) 
						{
							doorsArr3D[i][5] = 0;
						}
					}
				}
			}
        }
        lastTime = timeNow;
		
		
				if(pickable_at_hand)
				{
					//alert("pora");
					var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
					projector.unprojectVector( vector, camera );
					var dir = vector.sub( camera.position ).normalize();
					dir.multiplyScalar( 10 );
					var pos = camera.position.clone().add( dir );
					//pos.y = pos.y - 3.5;
					//pos.y *= 6.4;
					//var looker = new THREE.Vector3(0, 0, 0).add(camera.look);
					//looker.sub(camera.position);
					//looker.x /=5;
					//looker.z /=5;
					//pos.add(looker.normalize());
					//pos.z+=8;

					pickable_at_hand.position = pos;
					
					pickable_at_hand_icon.style.left = x_pos + 'px';
					pickable_at_hand_icon.style.top = y_pos + 'px';
				}
				
		
		
				render();
				
				
				
				
				// create a Ray with origin at the mouse position
				//   and direction into the scene (camera direction)
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );
				var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				// create an array containing all objects in the scene with which the ray intersects
				var intersects = ray.intersectObjects( scene.children );

				// INTERSECTED = the object in the scene currently closest to the camera 
				//		and intersected by the Ray projected from the mouse position 	
				
				// if there is one (or more) intersections
				if ( intersects.length > 0 )
				{
					//alert("intersecting!" + intersects.length);
					// if the closest object intersected is not the currently stored intersection object
					if ( intersects[ 0 ].object != INTERSECTED ) 
					{
					//	alert("intersecting!");w
						// restore previous intersection object (if it exists) to its original color
						if ( INTERSECTED ) 
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						// store reference to closest object as current intersection object
						INTERSECTED = intersects[ 0 ].object;
						// store color of closest object (for later restoration)
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
						// set a new color for closest object
						INTERSECTED.material.color.setHex( 0xffff00 );
						
						
					}
				}
	
	
	

			}

			function render() {


				renderer.render( scene, camera );

			}

		</script>

		<img id="pickable_at_hand_id" src="none.png" style="position:absolute; left:-170px;" />
		
	</body>
</html>
